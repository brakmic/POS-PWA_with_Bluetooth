"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onlyForTesting = void 0;
const middleware_1 = require("./middleware");
const utl_1 = __importDefault(require("../utl"));
class PathMiddleware {
    constructor() {
        this.path = (operationId, { operationObject, validate, exclude, }) => {
            if (this.operations.has(operationId)) {
                throw new Error('operationId must be unique per express app');
            }
            validate = validate === undefined ? this.validate : validate;
            if (validate) {
                if (!operationObject) {
                    throw new Error('Required open api path operation for validation is missing');
                }
                this.validatorQueue.push(operationId);
            }
            return (0, middleware_1.middleware)(operationId, this.operations, exclude, operationObject);
        };
        this.initializeValidation = (openApiDoc, ajv) => {
            this.validate = true;
            if (!openApiDoc || !ajv) {
                throw new Error('OpenApi document and Ajv instance required for path validation');
            }
            if (openApiDoc.components) {
                for (const field of Object.keys(openApiDoc.components)) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    for (const [name, component] of Object.entries(openApiDoc.components[field])) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        ajv.addSchema(component, `#/components/${field}/${name}`);
                    }
                }
            }
            for (const operationId of this.validatorQueue) {
                if (this.operations.has(operationId)) {
                    throw new Error(`OperationId ${operationId} is not unique. Must be unique per Express App.`);
                }
                this.operations.set(operationId, makeValidator(operationId, openApiDoc, ajv));
            }
            this.validatorQueue = [];
        };
        this.validate = false;
        this.operations = new Map();
        this.validatorQueue = [];
    }
    /**
     * Initializes the validation feature for the path middlewares. Must be placed right before starting Express app.
     *
     * @param openApiDoc - Document that is used to validate routes. OperationId's must match pathMiddleware operationIds
     * @param ajv - Ajv client instance - user configured, provided and defined.
     * @throws
     * - If no path middleware have been created (attached to at least one route)
     * - If open api document or ajv instances is missing
     * - If an operationId is not unique
     * - If an operation object on the OpenApiv3 document was not found with one of the operationIds
     */
    static initializeValidation(openApiDoc, ajv) {
        if (!PathMiddleware.instance) {
            throw new Error('Instance not initialized, OpenApiPathMiddleware.initializeValidation requires path middleware on at least one route');
        }
        PathMiddleware.instance.initializeValidation(openApiDoc, ajv);
    }
    /**
     * Creates a path middleware that attaches to a route, providing meta-data for the express parser to pick up.
     *
     * @param  operationId - Required unique Express App wide id representing this specific operation in the open api schema.
     * @param  param - Object to hold optional parameters
     * @param  param.operationObject - The Open Api operation object for this route.
     * @param  param.validate - Overrides global validation option for this route.
     * @param  param.exclude - Indicates if this route should be marked for exclusion when generating OpenApi documents.
     * @returns An Express middleware object to attach to a route
     * @throws
     * - If operationId is not unique per express app,
     * - If validation is selected and no OpenApi document is provided.
     */
    static path(operationId, { operationObject, validate = false, exclude = false, }) {
        if (!PathMiddleware.instance) {
            PathMiddleware.instance = new PathMiddleware();
        }
        return PathMiddleware.instance.path(operationId, { operationObject, validate, exclude });
    }
}
exports.default = PathMiddleware;
const makeValidator = (operationId, doc, ajv) => {
    var _a, _b;
    const operation = selectOperation(operationId, doc.paths);
    if (!operation) {
        throw new Error(`provided operationId: ${operationId} is not in provided open api document`);
    }
    const reqSchema = Object.assign({}, (0, utl_1.default)(BASE_REQ_SCHEMA));
    if (operation && operation.parameters) {
        const map = { path: 'params', query: 'query', header: 'headers' };
        for (let p of operation === null || operation === void 0 ? void 0 : operation.parameters) {
            if (p === null || p === void 0 ? void 0 : p.$ref) {
                p = resolveReference(doc, p.$ref);
            }
            p = p;
            reqSchema.properties[map[p.in]].properties[p.name] = (0, utl_1.default)(p.schema);
            if (p.required && !reqSchema.properties[map[p.in]].required.includes(p.name)) {
                reqSchema.properties[map[p.in]].required.push(p.name);
            }
        }
    }
    const requestBody = ((_a = operation === null || operation === void 0 ? void 0 : operation.requestBody) === null || _a === void 0 ? void 0 : _a.$ref)
        ? resolveReference(doc, (operation === null || operation === void 0 ? void 0 : operation.requestBody).$ref)
        : operation === null || operation === void 0 ? void 0 : operation.requestBody;
    const requestBodySchema = (_b = requestBody === null || requestBody === void 0 ? void 0 : requestBody.content['application/json']) === null || _b === void 0 ? void 0 : _b.schema;
    if (requestBodySchema) {
        reqSchema.properties.body = Object.assign({}, requestBodySchema);
        if (requestBody.required) {
            reqSchema.required.push('body');
        }
    }
    return ajv.compile(reqSchema);
};
const selectOperation = (operationId, paths) => {
    for (const path of Object.values(paths)) {
        if (!path)
            continue;
        for (const op of Object.values(path)) {
            if ((op === null || op === void 0 ? void 0 : op.operationId) === operationId) {
                return op;
            }
        }
    }
    return undefined;
};
const resolveReference = (document, ref) => {
    const selector = ref.split('/');
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
        return (0, utl_1.default)(document[selector[1]][selector[2]][selector[3]]);
    }
    catch (e) {
        throw new Error('provided document reference is not in standard format: ' + ref);
    }
};
const BASE_REQ_SCHEMA = {
    type: 'object',
    required: ['headers', 'params', 'query'],
    properties: {
        headers: {
            type: 'object',
            required: [],
            properties: {},
        },
        params: {
            type: 'object',
            required: [],
            properties: {},
        },
        query: {
            type: 'object',
            required: [],
            properties: {},
        },
    },
};
exports.onlyForTesting = { makeValidator, selectOperation };
