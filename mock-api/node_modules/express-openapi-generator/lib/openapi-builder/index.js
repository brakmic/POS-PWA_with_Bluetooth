"use strict";
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable no-underscore-dangle */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.onlyForTesting = void 0;
const types_1 = require("../types");
const express_route_parser_1 = require("express-route-parser");
const utl_1 = __importDefault(require("../utl"));
class DocumentBuilder {
    constructor(documentStub) {
        /**
         * A builder method to generate allOf schemas.
         *
         * @param names List of names of schemas in the components of this document
         * @returns A valid allOf schema object, using $ref syntax to reference component schemas
         */
        this.allOf = (names) => {
            return this.compositeSchema(types_1.CompositeSchemaTypes.allOf, names);
        };
        /**
         * A builder method to generate oneOf schemas.
         *
         * @param names List of names of schemas in the components of this document
         * @returns A valid oneOf schema object, using $ref syntax to reference component schemas
         */
        this.oneOf = (names) => {
            return this.compositeSchema(types_1.CompositeSchemaTypes.oneOf, names);
        };
        /**
         * A builder method to generate anyOf schemas.
         *
         * @param names List of names of schemas in the components of this document
         * @returns A valid anyOf schema object, using $ref syntax to reference component schemas
         */
        this.anyOf = (names) => {
            return this.compositeSchema(types_1.CompositeSchemaTypes.anyOf, names);
        };
        /**
         * A builder method that can create an allOf, oneOf, anyOf schema objects.
         *
         * @param type One of 'anyOf', 'oneOf', 'allOf', selecting which will be created
         * @param names List of names of schemas in the components of this document
         * @returns A valid allOf, oneOf, anyOf schema object, using $ref syntax to reference component schemas
         * @throws Error if a component name doesn't exist on the document
         */
        this.compositeSchema = (type, names) => {
            const composite = {};
            composite[type] = names.map((name) => {
                const ref = this.schema(name);
                if (!ref) {
                    throw new Error(`Provided component name ${name} does not exist on the document`);
                }
                return ref;
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            return composite;
        };
        /**
         * A method for adding and retrieving components from the document
         *
         * @param field The category of the component, based on the OpenApiv3 spec
         * @param name The name of the component object
         * @param params Options
         * @param params.component If this is included, the component will be added to the document,
         * overriding existing components with the same name and field
         * @param params.copy If this is included, return a full copy, not just a $ref of the request component
         * @returns The component or undefined if it doesn't exist on the document
         * @throws If the field name is not one of {@link ComponentFieldNames}
         */
        this.component = (field, name, params) => {
            if (!Object.values(types_1.ComponentFieldNames).includes(field)) {
                throw new Error(`Provided component fields - ${field} - is invalid, must be one of: ${Object.values(types_1.ComponentFieldNames).toString()}`);
            }
            if (params === null || params === void 0 ? void 0 : params.component) {
                if (!this._document.components) {
                    this._document.components = {};
                }
                if (!this._document.components[field]) {
                    this._document.components[field] = {};
                }
                params.component = (0, utl_1.default)(params.component);
                this.components.set(`${field}-${name}`, params.component);
                this._document.components[field][name] = params.component;
            }
            const key = `${field}-${name}`;
            if (!this.components.has(key)) {
                return undefined;
            }
            return (params === null || params === void 0 ? void 0 : params.copy) ? (0, utl_1.default)(this.components.get(key)) : { $ref: `#/components/${field}/${name}` };
        };
        /**
         * A method for adding and retrieving schema components from the document
         *
         * @param name The name of the schema component
         * @param params Options
         * @param params.component If this is included, the schema will be added to the document,
         * overriding existing schema of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested schema
         * @returns The schema or undefined if it doesn't exist on the document
         */
        this.schema = (name, params) => {
            return this.component(types_1.ComponentFieldNames.schemas, name, params);
        };
        /**
         * A method for adding and retrieving response components from the document
         *
         * @param name The name of the response component
         * @param params Options
         * @param params.component If this is included, the response will be added to the document,
         * overriding existing response of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested response
         * @returns The response or undefined if it doesn't exist on the document
         */
        this.response = (name, params) => {
            return this.component(types_1.ComponentFieldNames.responses, name, params);
        };
        /**
         * A method for adding and retrieving parameter components from the document
         *
         * @param name The name of the parameter component
         * @param params Options
         * @param params.component If this is included, the parameter will be added to the document,
         * overriding existing parameter of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested parameter
         * @returns The parameter or undefined if it doesn't exist on the document
         */
        this.parameter = (name, params) => {
            return this.component(types_1.ComponentFieldNames.parameters, name, params);
        };
        /**
         * A method for adding and retrieving example components from the document
         *
         * @param name The name of the example component
         * @param params Options
         * @param params.component If this is included, the example will be added to the document,
         * overriding existing example of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested example
         * @returns The example or undefined if it doesn't exist on the document
         */
        this.example = (name, params) => {
            return this.component(types_1.ComponentFieldNames.examples, name, params);
        };
        /**
         * A method for adding and retrieving requestBody components from the document
         *
         * @param name The name of the requestBody component
         * @param params Options
         * @param params.component If this is included, the requestBody will be added to the document,
         * overriding existing requestBody of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested requestBody
         * @returns The requestBody or undefined if it doesn't exist on the document
         */
        this.requestBody = (name, params) => {
            return this.component(types_1.ComponentFieldNames.requestBodies, name, params);
        };
        /**
         * A method for adding and retrieving header components from the document
         *
         * @param name The name of the header component
         * @param params Options
         * @param params.component If this is included, the header will be added to the document,
         * overriding existing header of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested header
         * @returns The header or undefined if it doesn't exist on the document
         */
        this.header = (name, params) => {
            return this.component(types_1.ComponentFieldNames.headers, name, params);
        };
        /**
         * A method for adding and retrieving securityScheme components from the document
         *
         * @param name The name of the securityScheme component
         * @param params Options
         * @param params.component If this is included, the securityScheme will be added to the document,
         * overriding existing securityScheme of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested securityScheme
         * @returns The securityScheme or undefined if it doesn't exist on the document
         */
        this.securityScheme = (name, params) => {
            return this.component(types_1.ComponentFieldNames.securitySchemes, name, params);
        };
        /**
         * A method for adding and retrieving link components from the document
         *
         * @param name The name of the link component
         * @param params Options
         * @param params.component If this is included, the link will be added to the document,
         * overriding existing link of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested link
         * @returns The link or undefined if it doesn't exist on the document
         */
        this.link = (name, params) => {
            return this.component(types_1.ComponentFieldNames.links, name, params);
        };
        /**
         * A method for adding and retrieving callback components from the document
         *
         * @param name The name of the callback component
         * @param params Options
         * @param params.component If this is included, the callback will be added to the document,
         * overriding existing callback of the same name
         * @param params.copy If this is included, return a full copy, not just a $ref of the requested callback
         * @returns The callback or undefined if it doesn't exist on the document
         */
        this.callback = (name, params) => {
            return this.component(types_1.ComponentFieldNames.callbacks, name, params);
        };
        this.buildPaths = (app, requireOpenApiDocs, includeExcludedPaths) => {
            var _a, _b, _c, _d, _e, _f, _g;
            const expressParserOutput = (0, express_route_parser_1.parseExpressApp)(app);
            const paths = {};
            for (const path of expressParserOutput) {
                const excludeThisPath = (((_a = path === null || path === void 0 ? void 0 : path.metadata) === null || _a === void 0 ? void 0 : _a.exclude) && !includeExcludedPaths) ||
                    (requireOpenApiDocs && !((_b = path === null || path === void 0 ? void 0 : path.metadata) === null || _b === void 0 ? void 0 : _b.operationObject));
                if (excludeThisPath) {
                    continue;
                }
                transformExpressPathToOpenApi(path);
                if (!paths[path.path]) {
                    paths[path.path] = {};
                }
                paths[path.path][path.method] = ((_c = path === null || path === void 0 ? void 0 : path.metadata) === null || _c === void 0 ? void 0 : _c.operationObject) || {};
                if ((_d = path === null || path === void 0 ? void 0 : path.metadata) === null || _d === void 0 ? void 0 : _d.operationId) {
                    paths[path.path][path.method].operationId = (_e = path === null || path === void 0 ? void 0 : path.metadata) === null || _e === void 0 ? void 0 : _e.operationId;
                }
                let parameters = ((_g = (_f = path === null || path === void 0 ? void 0 : path.metadata) === null || _f === void 0 ? void 0 : _f.operationObject) === null || _g === void 0 ? void 0 : _g.parameters) || [];
                parameters = this.mergeParameters(parameters, path);
                if (parameters.length > 0) {
                    paths[path.path][path.method].parameters = parameters;
                }
                if (!paths[path.path][path.method].responses) {
                    paths[path.path][path.method].responses = {
                        default: { description: 'Responses object not provided for this route' },
                    };
                }
            }
            return paths;
        };
        this.mergeParameters = (parameters, path) => {
            var _a;
            for (let i = 0; i < parameters.length; i++) {
                for (let j = 0; j < path.pathParams.length; j++) {
                    if (parameters[i].$ref) {
                        parameters[i] = this.parameter(parameters[i].$ref.split('/')[3], {
                            copy: true,
                        });
                    }
                    if (((_a = parameters[i]) === null || _a === void 0 ? void 0 : _a.name) === path.pathParams[j].name) {
                        parameters[i] = Object.assign(path.pathParams[j], parameters[i]);
                        path.pathParams.splice(j, 1);
                        break;
                    }
                }
            }
            const params = path.pathParams.map((p) => {
                p.schema = { type: 'string' };
                return p;
            });
            return [...parameters, ...params];
        };
        documentStub = (0, utl_1.default)(documentStub);
        const missingFields = verifyBasicOpenApiReqs(documentStub);
        if (missingFields) {
            throw new Error('Provided Open Api stub document is missing the following fields: ' + missingFields);
        }
        this._document = documentStub;
        this.components = new Map();
        this.processComponents();
    }
    /**
     * Deletes the singleton instance, allowing re-initialization if desired.
     */
    static deleteDocumentInstance() {
        if (DocumentBuilder.instance) {
            delete DocumentBuilder.instance;
        }
    }
    /**
     * Initializes the singleton document. This allows you to import this class from
     * any module and maintain an global document reference.
     *
     * @remarks
     * **Warning**: Each call to this method will override previous instances, loosing the internal document.
     * Recommended to only call this once per project.
     *
     * @param documentStub The minimum required OpenApiv3 skeleton spec
     * @returns The document builder object instance
     */
    static initializeDocument(documentStub) {
        DocumentBuilder.instance = new DocumentBuilder(documentStub);
        return DocumentBuilder.instance;
    }
    /**
     * Initializes and returns an instance of a DocumentBuilder that is not attached to the
     * static reference of DocumentBuilder.
     * Allows you to create a second document builder object, export it and use however desired.
     *
     * **Does NOT** override the underlying singleton instance
     *
     * @param documentStub The minimum required OpenApiv3 skeleton spec
     * @returns The newly created document builder object
     */
    static initializeDetachedDocument(documentStub) {
        return new DocumentBuilder(documentStub);
    }
    /**
     * Retrieves the current document builder instance.
     * Used to retrieve references across modules.
     */
    static get documentBuilder() {
        if (!DocumentBuilder.instance) {
            throw new Error('Must initialize document before getting builder instance');
        }
        return DocumentBuilder.instance;
    }
    /**
     * Parses the express app and builds an OpenApiv3 Paths object
     *
     * @remarks
     * **Warning**: This must be used after all other routes have been attached
     * and processed onto the express app. Suggested to be placed right before app.listen().
     *
     * You may use this, build a document, then use this method with different flags and build again for multiple
     * versions of the OpenApi v3 document.
     *
     * This allows you to remove routes you don't want documented on one doc, but include it on another.
     *
     * @param app The Express App object
     * @param requireOpenApiDocs Require extended OpenApi middleware documentation to exist to include the route in the final Paths Object
     * @param includeExcludedPaths Override the exclude flag that was attached by middleware and include those routes in the final Paths Object
     */
    generatePathsObject(app, requireOpenApiDocs = false, includeExcludedPaths = false) {
        this._document.paths = this.buildPaths(app, requireOpenApiDocs, includeExcludedPaths);
    }
    /**
     *
     * @returns A deep copy of the current OpenApi v3 document
     */
    build() {
        return (0, utl_1.default)(this._document);
    }
    processComponents() {
        if (!this._document.components) {
            return;
        }
        for (const [field, components] of Object.entries(this._document.components)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            for (const [name, component] of Object.entries(components)) {
                this.component(field, name, { component: component });
            }
        }
    }
}
exports.default = DocumentBuilder;
const verifyBasicOpenApiReqs = (openApiDoc) => {
    var _a, _b;
    let missingFields = (openApiDoc === null || openApiDoc === void 0 ? void 0 : openApiDoc.openapi) ? '' : 'openapi, ';
    missingFields += (openApiDoc === null || openApiDoc === void 0 ? void 0 : openApiDoc.info) ? '' : 'info, ';
    missingFields += ((_a = openApiDoc === null || openApiDoc === void 0 ? void 0 : openApiDoc.info) === null || _a === void 0 ? void 0 : _a.title) ? '' : 'title ';
    missingFields += ((_b = openApiDoc === null || openApiDoc === void 0 ? void 0 : openApiDoc.info) === null || _b === void 0 ? void 0 : _b.version) ? '' : 'and version.';
    return missingFields;
};
const transformExpressPathToOpenApi = (path) => {
    path.pathParams.forEach((param) => {
        path.path = path.path.replace(`:${param.name}`, `{${param.name}}`);
    });
};
exports.onlyForTesting = {
    verifyBasicOpenApiReqs,
    transformExpressPathToOpenApi,
};
